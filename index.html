<!doctype html>
<html lang="en">
    <head>
        <link rel="icon" href="https://www.pngitem.com/pimgs/m/58-588414_png-lifting-weights-icon-weight-lifting-transparent-png.png">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Weightlift Progress</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="https://rawgit.com/gionkunz/chartist-js/master/dist/chartist.min.css">
        <style>
            #chart {
                height: 300px;
                width: 100%;
            }
        </style>
        <script type="text/javascript" src="https://rawgit.com/gionkunz/chartist-js/master/dist/chartist.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/chartist-plugin-legend/0.6.2/chartist-plugin-legend.min.js"></script>

        <style>
        /* change series colors with this, just replace a with b and so on and specify the color. note below series 0,1,2,3 etc.
        where it's change as well for the legend purposes */
        .ct-series-a .ct-bar, .ct-series-a .ct-line, .ct-series-a .ct-point, .ct-series-a .ct-slice-donut {
		    stroke: #F75590;
		    }

        .ct-series-b .ct-bar, .ct-series-b .ct-line, .ct-series-b .ct-point, .ct-series-b .ct-slice-donut {
        stroke: #81C14B;
        }

        .ct-series-c .ct-bar, .ct-series-c .ct-line, .ct-series-c .ct-point, .ct-series-c .ct-slice-donut {
        stroke: #FF6700;
        }

        .ct-series-d .ct-bar, .ct-series-d .ct-line, .ct-series-d .ct-point, .ct-series-d .ct-slice-donut {
        stroke: #7DBBC3;
        }



       .ct-chart {
           position: relative;
       }
       .ct-legend {
           position: relative;
           z-index: 10;
           list-style: none;
           text-align: center;
       }
       .ct-legend li {
           position: relative;
           padding-left: 23px;
           margin-right: 10px;
           margin-bottom: 3px;
           cursor: pointer;
           display: inline-block;
       }
       .ct-legend li:before {
           width: 12px;
           height: 12px;
           position: absolute;
           left: 0;
           content: '';
           border: 3px solid transparent;
           border-radius: 2px;
       }
       .ct-legend li.inactive:before {
           background: transparent;
       }
       .ct-legend.ct-legend-inside {
           position: absolute;
           top: 0;
           right: 0;
       }
       .ct-legend.ct-legend-inside li{
           display: block;
           margin: 0;
       }
       .ct-legend .ct-series-0:before {
           background-color: #F75590;
           border-color: #F75590;
       }
       .ct-legend .ct-series-1:before {
           background-color: #81C14B;
           border-color: #81C14B;
       }
       .ct-legend .ct-series-2:before {
           background-color: #FF6700;
           border-color: #FF6700;
       }
       .ct-legend .ct-series-3:before {
           background-color: #7DBBC3;
           border-color: #7DBBC3;
       }
       .ct-legend .ct-series-4:before {
           background-color: #453d3f;
           border-color: #453d3f;
       }
       
       .ct-chart-line-multipleseries .ct-legend .ct-series-0:before {
           background-color: #F75590;
           border-color: #F75590;
       }
       
       .ct-chart-line-multipleseries .ct-legend .ct-series-1:before {
           background-color: #FF6700;
           border-color: #FF6700;
       }
       
       .ct-chart-line-multipleseries .ct-legend li.inactive:before {
           background: transparent;
       }

       .crazyPink li.ct-series-0:before {
          background-color: #C2185B;
          border-color: #C2185B;
       }

       .crazyPink li.ct-series-1:before {
          background-color: #E91E63;
          border-color: #E91E63;
       }

       .crazyPink li.ct-series-2:before {
          background-color: #F06292;
          border-color: #F06292;
       }
       .crazyPink li.inactive:before {
          background-color: transparent;
       }

       .crazyPink ~ svg .ct-series-a .ct-line, .crazyPink ~ svg .ct-series-a .ct-point {
          stroke: #C2185B;
       }

       .crazyPink ~ svg .ct-series-b .ct-line, .crazyPink ~ svg .ct-series-b .ct-point {
          stroke: #E91E63;
       }

       .crazyPink ~ svg .ct-series-c .ct-line, .crazyPink ~ svg .ct-series-c .ct-point {
          stroke: #F06292;
       }
       /* Page styling */
       h1, h2, h3{
          color: #5b4421;
          text-transform: uppercase;
       }

       h1, h2{
          text-align: center;
       }

       h3 > * {
          text-transform: none;
       }

       .codeblock-hidden{
          display: none;
       }

      .javascript.hljs {
             background-color: #453D3F;
             padding: 1.3333333333rem;
             color: #f7f2ea;
             font-family: "Source Code Pro","Courier New",monospace!important;
             line-height: 1.4;
             word-wrap: break-word;
             height: auto;
             margin-bottom: 1.3333333333rem
       }

       .ct-hidden {
          opacity: 0;
       }

       .ct-dimmed {
          opacity: 0.5;
       }

       .javascript.hljs span::selection, .javascript.hljs::selection {
         background: #2a2526!important
       }

       .javascript.hljs .hljs-comment {
             color: #7b6d70
       }

       .javascript.hljs .hljs-atom,.javascript.hljs .hljs-number {
             color: #FF6700
       }

       .cm-s-3024-day .hljs-attribute,.javascript.hljs .hljs-property {
             color: #f7f2ea
       }

       .javascript.hljs .hljs-keyword {
             color: #81C14B;
             font-weight: 700
       }

       .javascript.hljs .hljs-string {
             color: #FF6700
       }

       .javascript.hljs .hljs-variable {
             color: #f7f2ea
       }

       .javascript.hljs .hljs-def,.javascript.hljs .hljs-variable-2 {
             color: #f8b3ad
       }

       .javascript.hljs .hljs-bracket {
             color: #3a3432
       }

       .javascript.hljs .hljs-tag {
             color: #81C14B;
             font-weight: 700
       }

       .javascript.hljs .hljs-link {
             color: #FF6700
       }

       .javascript.hljs .hljs-error{
             background-color: #81C14B;
             color: #453D3F
       }

       .javascript.hljs .hljs-literal{
             color: #81C14B;
       }

       .javascript.hljs .CodeMirror-activeline-background {
             background: #e8f2ff!important
       }

       .javascript.hljs .CodeMirror-matchingbracket {
             text-decoration: underline;
             color: #fff!important
       }
       body {
          background: #EADBC4;
          line-height: 1.54;
          background-position: 50% 50%;
          font-family:'Helvetica';
       }
       h2, h3, h4, h5, h6, p {
          font-family:'Helvetica';
          text-align: center;
       }
       div {
        font-family:'Helvetica';
       }
      * {
        box-sizing: border-box;
      }

      /* Create four equal columns that floats next to each other */
      .column {
        float: left;
        width: 25%;
        padding: 10px;
      }

      /* Clear floats after the columns */
      .row:after {
        content: "";
        display: table;
        clear: both;
      }

      /* Responsive layout - makes a two column-layout instead of four columns */
      @media screen and (max-width: 900px) {
        .column  {
          width: 50%;
        }
      }

      /* Responsive layout - makes the two columns stack on top of each other instead of next to each other */
      @media screen and (max-width: 600px) {
        .column  {
          width: 100%;
        }
      }
      .gap{background:none;height:50px;display:inline-block;}

    </style>





    </head>
    <body>
        <div class="ct-chart" id="chart"></div>

        <div class="gap"></div>

        <div class="row">
          <div class="column" style="background-color:#F75590;">
          <h4>Bench Press</h4>
          <p id="benchpress"></p>
          </div>
          <div class="column" style="background-color:#81C14B;">
          <h4>Squat</h4>
          <p id="squat"></p>
          </div>
          <div class="column" style="background-color:#FF6700;">
          <h4>Shoulder Press</h4>
          <p id="shoulderpress"></p>
          </div>
          <div class="column" style="background-color:#7DBBC3;">
          <h4>Bodyweight</h4>
          <p id="bodyweight"></p>
          </div>
        </div>
        <script>

        var data = {
    			labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    			series: [
    			    [5, 5, 10, 8, 7, 5, 4, null, null, null, 10, 10, 7, 8, 6, 9],
    			    [10, 15, null, 12, null, 10, 12, 15, null, null, 12, null, 14, null, null, null],
    			    [null, null, null, null, 3, 4, 1, 3, 4,  6,  7,  9, 5, null, null, null],
    			    [null, 15, null, 13, 17, 11, 12, 11, null, null, null, null, 17, null, null, null]
    			]
        }

        var options = {
    			fullWidth: true,
    			chartPadding: {
    				right:30
    			},
    			plugins: [
    		        Chartist.plugins.legend({
    		            legendNames: ['Bench Press', 'Squat', 'Shoulder Press', 'Weight'],
    		        })
    		    ],
    			lineSmooth: Chartist.Interpolation.cardinal({
    				fillHoles: true,
    			}),
    			low: 0
    		}

        var responsiveOptions = [
    			['screen and (min-width: 300px)', {
    				axisX: {
    					labelInterpolationFnc: function(value, index) {
    						return (index % ~~(data.labels.length / 20) === 0 || data.labels.length <= 20) ? value : null;
    						// ~~ is a bitwise operator to get whole number so we get total data points / 20 = however many. And every so often on that we plot a label. So plot 20 labels
    					}
    				}
    			}]
    		];

        var chart = new Chartist.Line('#chart', data, options, responsiveOptions);

        function calc_max(weight, reps) {
          // Brzycki
          if (reps < 10) {
            var max = weight * (36 / (37-reps)); // will work for actual 1RM
          } else {
          // Eply
            var max = weight * (1 + (reps / 30));
          }
          return max;
        }

        function csvJSON(csv) {
          var lines=csv.split("\n");
          var result = [];
          var headers=lines[0].split(",");
          for(var i=1;i<lines.length;i++){
              var obj = {};
              var currentline=lines[i].split(",");
              for(var j=0;j<headers.length;j++){
                  obj[headers[j]] = currentline[j];
              }
              result.push(obj);
          }
          return result;
        }

        // use a cors header proxy and get the csv i published
        const proxyurl = "https://cors-anywhere.herokuapp.com/";
        const url = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSgea157RpJMjcWTrTX_nanhQ0dtVBaXvehQmxYojLgRoUMV_hQZ5JfVrTdCcCT520kSTTh891Q89YD/pub?gid=719380801&single=true&output=csv"; 
        // site that doesn’t send Access-Control-*
        fetch(proxyurl + url) // https://cors-anywhere.herokuapp.com/https://example.com
        .then(response => response.text())
        .then(
          function(contents) {
            // this is where we do everything

            var cont = csvJSON(contents);
            console.log(cont);
            bw = cont[cont.length - 1].BodyWeight
            console.log(typeof(bw))
            document.getElementById("bodyweight").innerText = bw;

            var benchpresses = []
            var shoulderpresses = []
            var squats = []
            // yup now modify this to collect all the stuff at the end
            // how do i track it, calulated max or performed max
            // need to decide
            for (entry of cont) {
              if (entry.Exercise === "Bench Press"){
                benchpresses.push(entry);
              }
              else if (entry.Exercise === "Overhead Press"){
                shoulderpresses.push(entry)
              }
              else if (entry.Exercise === "Squat"){
                squats.push(entry)
              }
            }


            // map each bench to the calculated max and take the projected or actual max
            var max_bench = Math.max(...benchpresses.map(function (bp) {return calc_max(parseFloat(bp.Weight), parseFloat(bp.Reps))}));
            document.getElementById("benchpress").innerText = String(Math.floor(max_bench));

            var max_squat = Math.max(...squats.map(function (sq) {return calc_max(parseFloat(sq.Weight), parseFloat(sq.Reps))}));
            document.getElementById("squat").innerText = String(Math.floor(max_squat));

            var max_shoulder = Math.max(...shoulderpresses.map(function (sh) {return calc_max(parseFloat(sh.Weight), parseFloat(sh.Reps))}));
            document.getElementById("shoulderpress").innerText = String(Math.floor(max_shoulder));



            arr = cont;
            arr.sort((a, b) => new Date(a.date) - new Date(b.date))
            // use this to sort from oldest to newest dates

            dates_and_maxes = []

            curr_bench_max = null
            curr_squat_max = null
            curr_shoulder_max = null

            curr_obj  = {}
            curr_date = arr[0]['Start Date (UTC)']
            curr_obj.bodyweight = arr[0]['BodyWeight']
            curr_obj.date = arr[0]['Start Date (UTC)']
            curr_obj.bench_max = curr_bench_max
            curr_obj.squat_max = curr_squat_max
            curr_obj.shoulder_max = curr_shoulder_max

            for (elem of arr){
              //if we're on the same date
              //cycle through and update maxes
              if (elem['Start Date (UTC)'] === curr_date) {
                if (elem.Exercise === "Bench Press"){
                  if (calc_max(elem.Weight, elem.Reps) > curr_obj.bench_max){
                    curr_obj.bench_max = calc_max(elem.Weight, elem.Reps)

                  }
                }
                if (elem.Exercise === "Squat"){
                  if (calc_max(elem.Weight, elem.Reps) > curr_obj.squat_max){
                    curr_obj.squat_max = calc_max(elem.Weight, elem.Reps)
                  }
                }
                if (elem.Exercise === "Overhead Press"){
                  if (calc_max(elem.Weight, elem.Reps) > curr_obj.shoulder_max){
                    curr_obj.shoulder_max = calc_max(elem.Weight, elem.Reps)
                  }
                }
              } 
              //if we've arrived at a new date, reset
              else {
                dates_and_maxes.push(curr_obj)
                curr_date = elem['Start Date (UTC)']
                curr_obj  = {}
                curr_obj.date = curr_date
                curr_obj.bodyweight = elem.BodyWeight
                curr_obj.bench_max = null
                curr_obj.squat_max = null
                curr_obj.shoulder_max = null
                if (elem.Exercise === "Bench Press"){
                  curr_obj.bench_max = calc_max(elem.Weight, elem.Reps)
                }
                else if (elem.Exercise === "Squat"){
                  curr_obj.squat_max = calc_max(elem.Weight, elem.Reps)
                }
                else if (elem.Exercise === "Overhead Press"){
                  curr_obj.squat_max = calc_max(elem.Weight, elem.Reps)
                }
              }
            }
            //at end append last one too
            dates_and_maxes.push(curr_obj)
            console.log(dates_and_maxes)
          }

        )
        

        /*now i gotta manipulate cont and graph right*/

        /*
        {
          "Name":"Upper Body Power",
          "Start Date (UTC)":"10/24/2020",
          "Start Time (UTC)":"4:14:00 PM",
          "End Date (UTC)":"10/24/2020",
          "End Time (UTC)":"5:14:00 PM",
          "BodyWeight":"162",
          "Exercise":"Bench Press",
          "Equipment":"Machine",
          "Reps":"10",
          "Weight":"125",
          "Time":"",
          "Distance":"",
          "Status":"Done",
          "Categories\r":"Pectorals\r"
        } --handle this /r thing
        */


        /* ANIMATION SECTION */
        var seq = 0,
    		delays = 2,
    		durations = 200;

    		// Once the chart is fully created we reset the sequence
    		chart.on('created', function() {
          console.log('created')
    			seq = 0;
    		});

    		// On each drawn element by Chartist we use the Chartist.Svg API to trigger SMIL animations
    		chart.on('draw', function(data) {
    			seq++;
    			if(data.type === 'line') {
    			// If the drawn element is a line we do a simple opacity fade in. This could also be achieved using CSS3 animations.
    				data.element.animate({
    			  		opacity: {
    					    // The delay when we like to start the animation
    					    begin: seq * delays,
    					    // Duration of the animation
    					    dur: durations,
    					    // The value where the animation should start
    					    from: 0,
    					    // The value where it should end
    					    to: 1
          				}
        			});
      			} else if(data.type === 'label' && data.axis === 'x') {
        			data.element.animate({
         				y: {
    				        begin: seq * delays,
    				        dur: durations,
    				        from: data.y + 100,
    				        to: data.y,
    				        // We can specify an easing function from Chartist.Svg.Easing
    				        easing: 'easeOutQuart'
          				}
        			});
      			} else if(data.type === 'label' && data.axis === 'y') {
        			data.element.animate({
          				x: {
    						begin: seq * delays,
    						dur: durations,
    						from: data.x - 100,
    						to: data.x,
    						easing: 'easeOutQuart'
          				}
        			});
      			} else if(data.type === 'point') {
        			data.element.animate({
          				x1: {
    				        begin: seq * delays,
    				        dur: durations,
    				        from: data.x - 10,
    				        to: data.x,
    				        easing: 'easeOutQuart'
          				},
          				x2: {
    						begin: seq * delays,
    						dur: durations,
    						from: data.x - 10,
    						to: data.x,
    						easing: 'easeOutQuart'
          				},
          				opacity: {
    				        begin: seq * delays,
    				        dur: durations,
    				        from: 0,
    				        to: 1,
    				        easing: 'easeOutQuart'
          				}
        			});
      			} else if(data.type === 'grid') {
    			    // Using data.axis we get x or y which we can use to construct our animation definition objects
    			    var pos1Animation = {
    					begin: seq * delays,
    					dur: durations,
    					from: data[data.axis.units.pos + '1'] - 30,
    					to: data[data.axis.units.pos + '1'],
    					easing: 'easeOutQuart'
        			};

        			var pos2Animation = {
    					begin: seq * delays,
    					dur: durations,
    					from: data[data.axis.units.pos + '2'] - 100,
    					to: data[data.axis.units.pos + '2'],
    					easing: 'easeOutQuart'
        			};

        			var animations = {};
    			    animations[data.axis.units.pos + '1'] = pos1Animation;
    			    animations[data.axis.units.pos + '2'] = pos2Animation;
    			    animations['opacity'] = {
    					begin: seq * delays,
    					dur: durations,
    					from: 0,
    					to: 1,
    					easing: 'easeOutQuart'
        			};

    				data.element.animate(animations);
      			}
    		});


        // the problem with the created and draw event listeners is that they refresh and redraw the chart on every 
        // screen resize and sometimes scrolling. so we remove the listeners on the chart and leave it in its final state
        // we do this after the drawing has finished so set a 3 second timeout before removing drawing abilities
        // might have to be longer (in case the cors herokuapp takes forever)
        setTimeout(function(){ chart.off('created'); chart.off('draw');}, 3000);
        </script>


    
    </body>


</html>